# V3.0 Release Documentation

## Overview

V3.0 introduces dynamic collision avoidance capabilities to the satellite control system. This major update enables the MPC controller to navigate complex environments with static and dynamic obstacles while maintaining optimal control performance.

---

## V3.0.0 â€” Collision Avoidance

### What Changed
The Model Predictive Control (MPC) formulation now includes hard constraints for obstacle avoidance. The system can handle spherical, cylindrical, and box-shaped obstacles defined in the mission configuration.

### Why
To enable realistic inspection missions in cluttered environments (e.g., inspecting a space station or debris field), the satellite must actively avoid collisions. Soft constraints (penalties) are insufficient for safety-critical avoidance; hard constraints guarantee safety margins are respected.

### Technical Details

#### 1. Integration with QP Solver
The MPC controller (`MPCControllerCpp`) now dynamically modifies the OSQP problem structure at each timestep:
- **Hard Constraints:** Each obstacle generates a linearized half-space constraint of the form $n^T p \ge d$ where $n$ is the normal vector and $d$ is the safety distance.
- **Dynamic Updates:** As the satellite moves, the linearization point changes, and the constraints are updated in real-time.
- **Performance:** efficient sparse matrix updates ensure solve times remain under 2ms.

#### 2. Obstacle Representation
New C++ classes in `satellite_collision` namespace:
- `Obstacle`: Defines geometry (Sphere, Cylinder, Box).
- `ObstacleSet`: Manages collections of obstacles and computes active linear constraints.

#### 3. Configuration & Visualization
- **Mission Config:** Obstacles are defined in Python `Mission` dataclasses and passed seamlessly to C++.
- **Visualization:** The 3D visualizer renders obstacles with correct geometry, and 2D plots show safety margins.

### Files Modified
- **C++ Backend:**
    - `src/satellite_control/cpp/obstacle.hpp/cpp`: Core geometry logic.
    - `src/satellite_control/cpp/mpc_controller.hpp/cpp`: QP constraint integration.
    - `src/satellite_control/cpp/bindings.cpp`: Python bindings.
- **Python Control:**
    - `src/satellite_control/core/mpc_runner.py`: Interface updates.
    - `src/satellite_control/config/models.py`: Pydantic validation for new params.
- **Mission & Vis:**
    - `src/satellite_control/mission/mission_types.py`: Obstacle dataclasses.
    - `src/satellite_control/visualization/unified_visualizer.py`: Rendering logic.

---

## Usage Example

To add obstacles to a mission progammatically:

```python
from src.satellite_control.mission.mission_types import Obstacle, ObstacleType
import numpy as np

# Define an obstacle
obs = Obstacle(
    type=ObstacleType.SPHERE,
    position=np.array([2.5, 0.0, 0.0]),
    radius=0.5,
    name="Debris_1"
)

# Add to mission state
mission_state.obstacles = [obs]
mission_state.obstacles_enabled = True
```

The MPC will automatically detect these obstacles and plan trajectories around them.
