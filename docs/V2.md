# V2.0 Release Documentation

## Overview

V2.0 is a major upgrade to the satellite control simulation, focusing on commercial-grade physics fidelity and performance optimization.

---

## V2.0.0 — C++ Physics Engine Default

### What Changed
The custom C++ physics engine replaces MuJoCo as the default for simulation. MuJoCo is retained only for post-simulation visualization/replay.

### Why
- **Performance:** C++ engine is 75x faster (0.002ms vs 0.15ms per step)
- **Integration:** RK4 (4th order) instead of Euler for better accuracy
- **Dependencies:** Removes MuJoCo as a runtime dependency

### Technical Details
The C++ simulation engine (`SimulationEngine` class) implements:
- 13-element state vector: `[x, y, z, qw, qx, qy, qz, vx, vy, vz, ωx, ωy, ωz]`
- RK4 integration for both translational and rotational dynamics
- Quaternion normalization after each step
- Body-to-world frame force transformation using rotation matrices

### Files Modified
- `src/satellite_control/core/simulation_initialization.py` — Always uses CppSatelliteSimulator
- `src/satellite_control/config/timing.py` — Single source of truth for `SIMULATION_DT`

---

## V2.1.0 — Nonlinear Orbital Dynamics

### What Changed
Replaced linearized Hill-Clohessy-Wiltshire (CW) equations with full Newtonian two-body gravity.

### Why
For commercial inspection satellite software, customers expect:
- Accurate physics at any distance (not just <100m)
- Support for eccentric orbits
- Validation against industry tools (STK, GMAT)

### The Physics

**CW (Linear) — V1.x:**
```
ax = 3n²·x + 2n·vy
ay = -2n·vx
az = -n²·z
```
This is a Taylor expansion valid only near circular orbits at small relative distances.

**Two-Body (Nonlinear) — V2.1.0:**
```
a = -μ/|r|³ × r
```
This is Newton's law of gravitation — exact for any distance and orbit type.

### How It Works
1. Target satellite orbits at radius R (default: 6,778 km, ~400 km altitude)
2. Each timestep, target position is propagated: `θ += n·dt`
3. Inspector acceleration = `a_inspector - a_target` (differential gravity)
4. RK4 integrates relative motion

### Files Modified
- `src/satellite_control/cpp/orbital_dynamics.hpp` — Added `TwoBodyDynamics` class
- `src/satellite_control/cpp/orbital_dynamics.cpp` — Newton gravity implementation
- `src/satellite_control/cpp/simulation_engine.cpp` — `use_nonlinear=true` default

---

## V2.2.0 — Successive Linearization MPC

### What Changed
MPC now re-linearizes the dynamics model every solve instead of caching it.

### Why
The MPC uses a linear model to predict future states. This model is only accurate near the point where it was linearized. During fast rotations, the satellite moves away from that point, causing prediction errors.

**Before:** Re-linearize only when quaternion changes by >0.05 (roughly 6°)
**After:** Re-linearize when quaternion changes by >0.001 (roughly 0.1°)

### Performance Impact
| Metric | Before | After |
|--------|--------|-------|
| MPC Solve Time | 0.8ms | 1.24ms |
| Re-linearizations | ~20% of solves | ~100% of solves |
| Accuracy during maneuvers | ⚠️ Degrades | ✅ Maintained |

The additional 0.4ms per solve is negligible compared to the 50ms control period.

### Files Modified
- `src/satellite_control/cpp/mpc_controller.cpp` — Line 321, threshold 0.05 → 0.001

---

## Performance Summary

| Metric | V1.x | V2.2.0 |
|--------|------|--------|
| Physics Engine | MuJoCo (Python) | C++ (custom) |
| Physics Step Time | ~0.15ms | **0.002ms** |
| MPC Solve Time | ~0.8ms | **1.24ms** |
| Orbital Dynamics | Linear (CW) | **Nonlinear (two-body)** |
| MPC Linearization | Sparse updates | **Continuous** |
| Simulation FPS | ~200 | **159** (higher fidelity) |

---

## Configuration

All timing is controlled from a single file:
```python
# src/satellite_control/config/timing.py
SIMULATION_DT = 0.001  # 1ms physics step (1000 Hz)
CONTROL_DT = 0.050     # 50ms MPC update (20 Hz)
```

---

## Upgrading from V1.x

No code changes required. The defaults have changed:
1. C++ engine is now default (no `--engine` flag needed)
2. Nonlinear dynamics are default (`use_nonlinear=true`)
3. Successive linearization is default (threshold = 0.001)

To run a simulation:
```bash
python run_simulation.py run
```
