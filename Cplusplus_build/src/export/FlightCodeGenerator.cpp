#include "export/FlightCodeGenerator.h"
#include <spdlog/spdlog.h>
#include <filesystem>
#include <iomanip>
#include <sstream>

namespace sat_sim::export_gen {

    namespace fs = std::filesystem;

    FlightCodeGenerator::FlightCodeGenerator(const GeneratorOptions& opts)
        : m_opts(opts) {}

    std::string FlightCodeGenerator::float_type() const {
        if (m_opts.use_fixed_point) {
            return "int32_t"; // Q16.16
        }
        return m_opts.platform == TargetPlatform::ARM_CORTEX_M ? "float" : "double";
    }

    bool FlightCodeGenerator::generate(const config::VehicleConfig& vehicle,
                                        int mpc_horizon, double mpc_dt) {
        m_files.clear();

        // Create output directory
        fs::create_directories(m_opts.output_dir);

        spdlog::info("FlightCodeGenerator: Generating code for '{}'", vehicle.name);
        spdlog::info("  Platform: {}", 
            m_opts.platform == TargetPlatform::ARM_CORTEX_M ? "ARM Cortex-M" :
            m_opts.platform == TargetPlatform::FPGA_HLS ? "FPGA HLS" : "Generic C");

        try {
            generate_types_header(vehicle);
            generate_control_allocator(vehicle);
            generate_controller(mpc_horizon, mpc_dt);
            generate_main_interface();
            generate_makefile();
        } catch (const std::exception& e) {
            spdlog::error("Code generation failed: {}", e.what());
            return false;
        }

        spdlog::info("FlightCodeGenerator: Generated {} files in '{}'", 
            m_files.size(), m_opts.output_dir);
        return true;
    }

    void FlightCodeGenerator::generate_types_header(const config::VehicleConfig& vehicle) {
        std::string path = m_opts.output_dir + "/" + m_opts.prefix + "types.h";
        std::ofstream f(path);

        f << "/**\n * @file " << m_opts.prefix << "types.h\n";
        f << " * @brief Auto-generated type definitions for " << vehicle.name << "\n";
        f << " * @note DO NOT EDIT - Generated by FlightCodeGenerator\n */\n\n";

        f << "#ifndef " << m_opts.prefix << "TYPES_H\n";
        f << "#define " << m_opts.prefix << "TYPES_H\n\n";

        f << "#include <stdint.h>\n\n";

        // Constants
        f << "/* Vehicle Parameters */\n";
        f << "#define " << m_opts.prefix << "NUM_THRUSTERS " << vehicle.thrusters.size() << "\n";
        f << "#define " << m_opts.prefix << "MASS " << std::fixed << std::setprecision(4) << vehicle.mass << "\n";
        f << "#define " << m_opts.prefix << "IX " << vehicle.inertia_diag.x() << "\n";
        f << "#define " << m_opts.prefix << "IY " << vehicle.inertia_diag.y() << "\n";
        f << "#define " << m_opts.prefix << "IZ " << vehicle.inertia_diag.z() << "\n\n";

        // Float type
        std::string ftype = float_type();
        f << "typedef " << ftype << " " << m_opts.prefix << "real_t;\n\n";

        // State vector
        f << "/* State Vector (13-DOF) */\n";
        f << "typedef struct {\n";
        f << "    " << m_opts.prefix << "real_t pos[3];      /* Position [m] */\n";
        f << "    " << m_opts.prefix << "real_t quat[4];     /* Quaternion [w,x,y,z] */\n";
        f << "    " << m_opts.prefix << "real_t vel[3];      /* Velocity [m/s] */\n";
        f << "    " << m_opts.prefix << "real_t omega[3];    /* Angular velocity [rad/s] */\n";
        f << "} " << m_opts.prefix << "state_t;\n\n";

        // Control input
        f << "/* Control Input */\n";
        f << "typedef struct {\n";
        f << "    " << m_opts.prefix << "real_t rw_torque[3];                          /* RW torques [Nm] */\n";
        f << "    " << m_opts.prefix << "real_t thrust[" << m_opts.prefix << "NUM_THRUSTERS];  /* Thruster forces [N] */\n";
        f << "} " << m_opts.prefix << "control_t;\n\n";

        f << "#endif /* " << m_opts.prefix << "TYPES_H */\n";

        f.close();
        m_files.push_back(path);
    }

    void FlightCodeGenerator::generate_control_allocator(const config::VehicleConfig& vehicle) {
        std::string path = m_opts.output_dir + "/" + m_opts.prefix + "allocator.c";
        std::ofstream f(path);

        f << "/**\n * @file " << m_opts.prefix << "allocator.c\n";
        f << " * @brief Control allocation (B-matrix)\n */\n\n";

        f << "#include \"" << m_opts.prefix << "types.h\"\n\n";

        // Generate B-matrix as static const
        int n = vehicle.thrusters.size();
        f << "/* B-matrix: maps thrust to [Fx,Fy,Fz,Tx,Ty,Tz] */\n";
        f << "static const " << m_opts.prefix << "real_t B_matrix[6][" << n << "] = {\n";

        for (int row = 0; row < 6; ++row) {
            f << "    {";
            for (int col = 0; col < n; ++col) {
                const auto& t = vehicle.thrusters[col];
                config::Vector3 dir = t.direction.normalized();
                config::Vector3 cross = t.position.cross(dir);

                double val = (row < 3) ? dir[row] : cross[row - 3];
                f << std::fixed << std::setprecision(6) << val;
                if (col < n - 1) f << ", ";
            }
            f << "}";
            if (row < 5) f << ",";
            f << "\n";
        }
        f << "};\n\n";

        // Allocation function
        f << "void " << m_opts.prefix << "compute_wrench(\n";
        f << "    const " << m_opts.prefix << "real_t thrust[" << m_opts.prefix << "NUM_THRUSTERS],\n";
        f << "    " << m_opts.prefix << "real_t force[3],\n";
        f << "    " << m_opts.prefix << "real_t torque[3])\n{\n";
        f << "    int i, j;\n";
        f << "    for (i = 0; i < 6; i++) {\n";
        f << "        " << m_opts.prefix << "real_t sum = 0;\n";
        f << "        for (j = 0; j < " << m_opts.prefix << "NUM_THRUSTERS; j++) {\n";
        f << "            sum += B_matrix[i][j] * thrust[j];\n";
        f << "        }\n";
        f << "        if (i < 3) force[i] = sum;\n";
        f << "        else torque[i-3] = sum;\n";
        f << "    }\n";
        f << "}\n";

        f.close();
        m_files.push_back(path);

        // Header
        std::string hpath = m_opts.output_dir + "/" + m_opts.prefix + "allocator.h";
        std::ofstream h(hpath);
        h << "#ifndef " << m_opts.prefix << "ALLOCATOR_H\n";
        h << "#define " << m_opts.prefix << "ALLOCATOR_H\n\n";
        h << "#include \"" << m_opts.prefix << "types.h\"\n\n";
        h << "void " << m_opts.prefix << "compute_wrench(\n";
        h << "    const " << m_opts.prefix << "real_t thrust[" << m_opts.prefix << "NUM_THRUSTERS],\n";
        h << "    " << m_opts.prefix << "real_t force[3],\n";
        h << "    " << m_opts.prefix << "real_t torque[3]);\n\n";
        h << "#endif\n";
        h.close();
        m_files.push_back(hpath);
    }

    void FlightCodeGenerator::generate_controller(int horizon, double dt) {
        std::string path = m_opts.output_dir + "/" + m_opts.prefix + "controller.c";
        std::ofstream f(path);

        f << "/**\n * @file " << m_opts.prefix << "controller.c\n";
        f << " * @brief Simplified proportional controller for embedded use\n */\n\n";

        f << "#include \"" << m_opts.prefix << "controller.h\"\n";
        f << "#include <math.h>\n\n";

        f << "#define DT " << std::fixed << std::setprecision(4) << dt << "\n";
        f << "#define HORIZON " << horizon << "\n\n";

        // Gains
        f << "/* Control gains */\n";
        f << "static const " << m_opts.prefix << "real_t Kp_pos = 2.0;\n";
        f << "static const " << m_opts.prefix << "real_t Kd_pos = 1.0;\n";
        f << "static const " << m_opts.prefix << "real_t Kp_att = 5.0;\n";
        f << "static const " << m_opts.prefix << "real_t Kd_att = 0.5;\n\n";

        // Simple controller (for embedded - full MPC would be too complex)
        f << "void " << m_opts.prefix << "compute_control(\n";
        f << "    const " << m_opts.prefix << "state_t* current,\n";
        f << "    const " << m_opts.prefix << "state_t* target,\n";
        f << "    " << m_opts.prefix << "control_t* output)\n{\n";
        f << "    int i;\n\n";

        f << "    /* Position error -> desired force */\n";
        f << "    " << m_opts.prefix << "real_t force_cmd[3];\n";
        f << "    for (i = 0; i < 3; i++) {\n";
        f << "        " << m_opts.prefix << "real_t pos_err = target->pos[i] - current->pos[i];\n";
        f << "        " << m_opts.prefix << "real_t vel_err = -current->vel[i]; /* Target vel = 0 */\n";
        f << "        force_cmd[i] = Kp_pos * pos_err + Kd_pos * vel_err;\n";
        f << "    }\n\n";

        f << "    /* Attitude error -> RW torque (simplified) */\n";
        f << "    for (i = 0; i < 3; i++) {\n";
        f << "        " << m_opts.prefix << "real_t att_err = target->quat[i+1] - current->quat[i+1];\n";
        f << "        " << m_opts.prefix << "real_t rate_err = -current->omega[i];\n";
        f << "        output->rw_torque[i] = Kp_att * att_err + Kd_att * rate_err;\n";
        f << "    }\n\n";

        f << "    /* Map force to thrusters (simple positive allocation) */\n";
        f << "    for (i = 0; i < " << m_opts.prefix << "NUM_THRUSTERS; i++) {\n";
        f << "        output->thrust[i] = 0.0;\n";
        f << "    }\n";
        f << "    /* +X thruster = force_cmd[0] if positive */\n";
        f << "    if (force_cmd[0] > 0) output->thrust[1] = force_cmd[0];\n";
        f << "    if (force_cmd[0] < 0) output->thrust[0] = -force_cmd[0];\n";
        f << "    if (force_cmd[1] > 0) output->thrust[3] = force_cmd[1];\n";
        f << "    if (force_cmd[1] < 0) output->thrust[2] = -force_cmd[1];\n";
        f << "    if (force_cmd[2] > 0) output->thrust[5] = force_cmd[2];\n";
        f << "    if (force_cmd[2] < 0) output->thrust[4] = -force_cmd[2];\n";
        f << "}\n";

        f.close();
        m_files.push_back(path);

        // Header
        std::string hpath = m_opts.output_dir + "/" + m_opts.prefix + "controller.h";
        std::ofstream h(hpath);
        h << "#ifndef " << m_opts.prefix << "CONTROLLER_H\n";
        h << "#define " << m_opts.prefix << "CONTROLLER_H\n\n";
        h << "#include \"" << m_opts.prefix << "types.h\"\n\n";
        h << "void " << m_opts.prefix << "compute_control(\n";
        h << "    const " << m_opts.prefix << "state_t* current,\n";
        h << "    const " << m_opts.prefix << "state_t* target,\n";
        h << "    " << m_opts.prefix << "control_t* output);\n\n";
        h << "#endif\n";
        h.close();
        m_files.push_back(hpath);
    }

    void FlightCodeGenerator::generate_main_interface() {
        std::string path = m_opts.output_dir + "/" + m_opts.prefix + "interface.h";
        std::ofstream f(path);

        f << "/**\n * @file " << m_opts.prefix << "interface.h\n";
        f << " * @brief Main interface for flight software integration\n */\n\n";

        f << "#ifndef " << m_opts.prefix << "INTERFACE_H\n";
        f << "#define " << m_opts.prefix << "INTERFACE_H\n\n";

        f << "#include \"" << m_opts.prefix << "types.h\"\n";
        f << "#include \"" << m_opts.prefix << "controller.h\"\n";
        f << "#include \"" << m_opts.prefix << "allocator.h\"\n\n";

        f << "/**\n * @brief Initialize controller (call once at startup)\n */\n";
        f << "static inline void " << m_opts.prefix << "init(void) {\n";
        f << "    /* No dynamic initialization needed */\n";
        f << "}\n\n";

        f << "/**\n * @brief Main control loop step\n";
        f << " * @param current Current state from sensors\n";
        f << " * @param target Target state\n";
        f << " * @param output Control output to actuators\n";
        f << " */\n";
        f << "static inline void " << m_opts.prefix << "step(\n";
        f << "    const " << m_opts.prefix << "state_t* current,\n";
        f << "    const " << m_opts.prefix << "state_t* target,\n";
        f << "    " << m_opts.prefix << "control_t* output)\n{\n";
        f << "    " << m_opts.prefix << "compute_control(current, target, output);\n";
        f << "}\n\n";

        f << "#endif /* " << m_opts.prefix << "INTERFACE_H */\n";

        f.close();
        m_files.push_back(path);
    }

    void FlightCodeGenerator::generate_makefile() {
        std::string path = m_opts.output_dir + "/Makefile";
        std::ofstream f(path);

        f << "# Auto-generated Makefile for flight code\n\n";

        f << "CC = gcc\n";
        if (m_opts.platform == TargetPlatform::ARM_CORTEX_M) {
            f << "CC = arm-none-eabi-gcc\n";
            f << "CFLAGS = -mcpu=cortex-m4 -mthumb -O2 -Wall\n";
        } else {
            f << "CFLAGS = -O2 -Wall -std=c99\n";
        }

        f << "\nSRCS = " << m_opts.prefix << "allocator.c " << m_opts.prefix << "controller.c\n";
        f << "OBJS = $(SRCS:.c=.o)\n";
        f << "LIB = lib" << m_opts.prefix << "control.a\n\n";

        f << "all: $(LIB)\n\n";
        f << "$(LIB): $(OBJS)\n";
        f << "\tar rcs $@ $^\n\n";
        f << "%.o: %.c\n";
        f << "\t$(CC) $(CFLAGS) -c $< -o $@\n\n";
        f << "clean:\n";
        f << "\trm -f $(OBJS) $(LIB)\n";

        f.close();
        m_files.push_back(path);
    }

} // namespace sat_sim::export_gen
